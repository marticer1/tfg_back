package com.tfg.backend.visualization;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.tfg.backend.algorithm.application.CreateEdgeUseCase;
import com.tfg.backend.algorithm.application.CreateNodeUseCase;
import com.tfg.backend.algorithm.application.dto.RegistrationEdgeDTO;
import com.tfg.backend.algorithm.application.dto.RegistrationNodeDTO;
import com.tfg.backend.algorithm.application.dto.Position3DDTO;
import com.tfg.backend.algorithm.domain.Algorithm;
import com.tfg.backend.algorithm.domain.NodeType;
import com.tfg.backend.algorithm.infrastructure.repositories.AlgorithmRepositoryJPA;
import com.tfg.backend.algorithm.infrastructure.repositories.EdgeRepositoryJPA;
import com.tfg.backend.algorithm.infrastructure.repositories.NodeRepositoryJPA;
import com.tfg.backend.problem.domain.Problem;
import com.tfg.backend.problem.infrastructure.repositories.ProblemRepositoryJPA;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.stream.Collectors;

/**
 * Service to process visualization JSON and persist nodes and edges to database
 */
@Service
public class VisualizationService {
    
    private static final int DEFAULT_COMPONENT_COUNT = 1;
    
    private final ObjectMapper objectMapper;
    private final CreateNodeUseCase createNodeUseCase;
    private final CreateEdgeUseCase createEdgeUseCase;
    private final AlgorithmRepositoryJPA algorithmRepositoryJPA;
    private final NodeRepositoryJPA nodeRepositoryJPA;
    private final EdgeRepositoryJPA edgeRepositoryJPA;
    private final ProblemRepositoryJPA problemRepositoryJPA;
    
    public VisualizationService(ObjectMapper objectMapper,
                               CreateNodeUseCase createNodeUseCase,
                               CreateEdgeUseCase createEdgeUseCase,
                               AlgorithmRepositoryJPA algorithmRepositoryJPA,
                               NodeRepositoryJPA nodeRepositoryJPA,
                               EdgeRepositoryJPA edgeRepositoryJPA,
                               ProblemRepositoryJPA problemRepositoryJPA) {
        this.objectMapper = objectMapper;
        this.createNodeUseCase = createNodeUseCase;
        this.createEdgeUseCase = createEdgeUseCase;
        this.algorithmRepositoryJPA = algorithmRepositoryJPA;
        this.nodeRepositoryJPA = nodeRepositoryJPA;
        this.edgeRepositoryJPA = edgeRepositoryJPA;
        this.problemRepositoryJPA = problemRepositoryJPA;
    }
    
    /**
     * Process visualization JSON and create nodes and edges in database
     * @param jsonPath Path to the JSON file generated by R scripts
     * @param problemId The problem ID these nodes belong to
     * @param useKKLayout If true, use Kamada-Kawai layout; otherwise use Fruchterman-Reingold
     */
    @Transactional
    public void processAndPersistVisualization(Path jsonPath, UUID problemId, boolean useKKLayout) throws IOException {
        if (jsonPath == null || !Files.exists(jsonPath)) {
            return;
        }
        
        // Read JSON file
        String jsonContent = Files.readString(jsonPath);
        VisualizationData vizData = objectMapper.readValue(jsonContent, VisualizationData.class);
        
        // Get all algorithms for this problem
        List<Algorithm> algorithms = algorithmRepositoryJPA.findByProblemId(problemId);
        Map<String, UUID> algorithmNameToId = algorithms.stream()
            .collect(Collectors.toMap(Algorithm::getName, Algorithm::getId));
        
        // Get the problem to check if it's a maximization problem
        Problem problem = problemRepositoryJPA.findById(problemId).orElse(null);
        boolean isMaximization = problem != null && problem.isMaximization();
        
        // Calculate min and max fitness values for z normalization
        double minFitness = Double.MAX_VALUE;
        double maxFitness = Double.MIN_VALUE;
        boolean hasValidFitness = false;
        for (VisualizationData.NodeData nodeData : vizData.getNodes()) {
            if (nodeData.getFitness() != null) {
                minFitness = Math.min(minFitness, nodeData.getFitness());
                maxFitness = Math.max(maxFitness, nodeData.getFitness());
                hasValidFitness = true;
            }
        }
        // If no valid fitness values, set defaults to avoid invalid calculations
        if (!hasValidFitness) {
            minFitness = 0.0;
            maxFitness = 0.0;
        }
        final double fitnessRange = maxFitness - minFitness;
        final double finalMinFitness = minFitness;
        final double finalMaxFitness = maxFitness;
        
        // Map to store node ID from JSON to actual persisted node UUID
        Map<String, UUID> nodeIdMap = new HashMap<>();
        
        // Process each node
        for (VisualizationData.NodeData nodeData : vizData.getNodes()) {
            // Determine which algorithm this node belongs to
            String algorithmName = nodeData.getAlgorithm();
            UUID algorithmId = null;
            
            if (algorithmName != null && !algorithmName.isEmpty() && !"NA".equals(algorithmName)) {
                algorithmId = algorithmNameToId.get(algorithmName);
            } else if (!algorithms.isEmpty()) {
                // For single algorithm case or shared nodes, use the first algorithm
                algorithmId = algorithms.get(0).getId();
            }
            
            if (algorithmId == null) {
                continue; // Skip this node if we can't determine the algorithm
            }
            
            // Map node type
            NodeType nodeType = mapNodeType(nodeData.getType());
            
            // Choose layout coordinates (prefer KK if specified, otherwise FR)
            Double x = useKKLayout ? nodeData.getX_kk() : nodeData.getX_fr();
            Double y = useKKLayout ? nodeData.getY_kk() : nodeData.getY_fr();
            Double z = calculateZ(nodeData.getFitness(), finalMinFitness, finalMaxFitness, fitnessRange, isMaximization);
            
            // Create position DTO
            Position3DDTO position = Position3DDTO.builder()
                .x(x)
                .y(y)
                .z(z)
                .build();
            
            // Create node DTO
            RegistrationNodeDTO nodeDTO = RegistrationNodeDTO.builder()
                .type(nodeType)
                .position(position)
                .build();
            
            // Persist node and store the mapping
            var responseNodeDTO = createNodeUseCase.execute(nodeDTO, algorithmId);
            nodeIdMap.put(nodeData.getId(), responseNodeDTO.getId());
        }
        
        // Process each edge
        if (vizData.getEdges() != null) {
            for (VisualizationData.EdgeData edgeData : vizData.getEdges()) {
                UUID sourceNodeId = nodeIdMap.get(edgeData.getFrom());
                UUID targetNodeId = nodeIdMap.get(edgeData.getTo());
                
                if (sourceNodeId == null || targetNodeId == null) {
                    continue; // Skip edge if either node doesn't exist
                }
                
                // Find the algorithm for this edge (use the algorithm of the source node)
                var sourceNode = nodeRepositoryJPA.findById(sourceNodeId).orElse(null);
                if (sourceNode == null) {
                    continue;
                }
                
                UUID algorithmId = sourceNode.getAlgorithm().getId();
                
                // Create edge DTO
                RegistrationEdgeDTO edgeDTO = RegistrationEdgeDTO.builder()
                    .sourceNodeId(sourceNodeId)
                    .targetNodeId(targetNodeId)
                    .build();
                
                // Persist edge
                createEdgeUseCase.execute(edgeDTO, algorithmId);
            }
        }
        
        // Update algorithm statistics - calculate per-algorithm counts
        for (Algorithm algorithm : algorithms) {
            // Recalculate from the database to ensure accuracy
            algorithm.setNodeCount(nodeRepositoryJPA.countByAlgorithmId(algorithm.getId()));
            algorithm.setEdgeCount(edgeRepositoryJPA.countByAlgorithmId(algorithm.getId()));
            
            // Component count is kept from stats if available, otherwise use default
            if (vizData.getStats() != null && vizData.getStats().getComponent_count() != null) {
                algorithm.setComponentCount(vizData.getStats().getComponent_count());
            } else {
                algorithm.setComponentCount(DEFAULT_COMPONENT_COUNT);
            }
            algorithmRepositoryJPA.save(algorithm);
        }
    }
    
    /**
     * Map string type to NodeType enum
     */
    private NodeType mapNodeType(String type) {
        if (type == null) {
            return NodeType.DEFAULT;
        }
        
        switch (type.toLowerCase()) {
            case "start":
                return NodeType.START;
            case "end":
                return NodeType.END;
            default:
                return NodeType.DEFAULT;
        }
    }
    
    /**
     * Calculate z coordinate based on fitness value and problem type.
     * For maximization problems: higher fitness = higher z (best solutions are at the top)
     * For minimization problems: lower fitness = higher z (best solutions are at the top)
     * 
     * @param fitness The fitness value of the node
     * @param minFitness The minimum fitness value across all nodes
     * @param maxFitness The maximum fitness value across all nodes
     * @param fitnessRange The range between max and min fitness
     * @param isMaximization Whether the problem is a maximization problem
     * @return The calculated z coordinate (normalized between 0 and 10)
     */
    private Double calculateZ(Double fitness, double minFitness, double maxFitness, 
                              double fitnessRange, boolean isMaximization) {
        if (fitness == null || fitnessRange <= 0) {
            return 0.0;
        }
        
        // Normalize fitness to [0, 1] range
        double normalizedFitness = (fitness - minFitness) / fitnessRange;
        
        double z;
        if (isMaximization) {
            // For maximization: higher fitness = higher z
            z = normalizedFitness;
        } else {
            // For minimization: lower fitness = higher z (invert the scale)
            z = 1.0 - normalizedFitness;
        }
        
        // Exaggerate z value by multiplying by 10 for better visual differentiation
        return z * 10.0;
    }
}
